#+TITLE: Main file of the phage repo
#+AUTHOR: Hugo Ávila (@bioinformagica)
#+LANGUAGE: en-us
#+STARTUP: overview
#+PROPERTY: header-args :dir ~/projects/phage-evo-paper :mkdirp yes :exports none :eval never-export

* ENV setup
** Snakemake
#+BEGIN_SRC shell
# get conda installer
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh

# Run installer and interactively accept and init the conda executable
# Atention !!!: this will change your current shell .rc (.zshrc, .bashrc ...)
bash Miniconda3-latest-Linux-x86_64.sh

# Source the conda changes
source ~/.bashrc

# Set auto activation of conda base environment to false
conda config --set auto_activate_base false

# Add channels
conda config --add channels conda-forge
conda config --add channels bioconda

# Install mamba
conda install -n base -c conda-forge mamba -y

# Install Snakemake
mamba create -c conda-forge -c bioconda -n snakemake snakemake -y

#+END_SRC

#+RESULTS:

* Snakemake workflow template
#+NAME: cb:get-snakemake-template
#+CAPTION: Clone the Snakemake Template
#+BEGIN_SRC shell
git clone https://github.com/snakemake-workflows/snakemake-workflow-template .
rm -rf .git
git init && git commit --allow-empty -m "Initial Commit."
#+END_SRC

* README.md
#+NAME: cb:README.md
#+CAPTION: README.md
#+BEGIN_SRC markdown :tangle README.md
# Snakemake workflow: `phage-evo-paper`

[![Snakemake](https://img.shields.io/badge/snakemake-≥6.3.0-brightgreen.svg)](https://snakemake.github.io)

A Snakemake workflow for `Phage directed evolution analysis`.
#+END_SRC
** DONE Create README.md
** TODO Create linter action
* Snakefile
:PROPERTIES:
:COOKIE_DATA: todo recursive
:header-args: :tangle workflow/Snakefile :mkdirp yes :exports none :eval never-export :comments link
:END:
** IMPORTS
#+BEGIN_SRC snakemake
import os
import sys
from operator import itemgetter as itget
import glob
#+END_SRC

** FILE CONFIGS
#+BEGIN_SRC snakemake
configfile: 'config/config.yaml'
#+END_SRC

** FUNCTIONS
#+BEGIN_SRC snakemake
get_cores_perc = lambda perc: max(1, workflow.cores * perc)
join_path = lambda *args: os.path.join(*args)
get_Kbs = lambda x: int(x/1_000)

def get_current_HEAD_hash(default='unnamed'):
    shell_CL = "git show-ref --head --heads --abbrev | grep HEAD | awk '{print $1}'"
    with os.popen(shell_CL) as f:
        git_hash = f.read().strip()
        if re.match('^[\w\d]{7}$', git_hash):
            return git_hash
        return default
#+END_SRC

** GLOBAL VARIABLES
#+BEGIN_SRC snakemake
snakefile_path = os.path.dirname(workflow.snakefile)
# SAMPLES=list(map(lambda x: os.path.basename(x.path).replace('.fastq',''), filter(lambda x: x.path.endswith('fastq'), os.scandir(config['reads']))))

# Prefixes
minia_prefix="minia.k{}.a{}".format(*itget("kmer","abundance")(config['params']['minia']))
pggb_prefix=".p{}.s{}.l{}".format(*itget("map_pct_id", "segment_length", "block_length")(config['params']['pggb']))

# Suffixes
filter_contigs_prefix = '.min{}Kb.max{}Kb'.format(*iter(map(get_Kbs, itget('min_contig_lenght', 'max_contig_lenght')(config['params']['minia']))))

SAMPLES, = glob_wildcards(join_path(config['data']['reads'], '{sample}.merged.fastq'))

# results_dir = config.get('results_dir', 'results')
results_dir = get_current_HEAD_hash()
#+END_SRC
** MAIN RULE ALL
#+BEGIN_SRC snakemake
rule all:
    input:
        rectangular_odgi = join_path('results', results_dir, 'plots', 'ggtree.ecoli.phages.passages.rectangular.pdf'),
        rectangular_fastani = join_path('results', results_dir, 'plots','fastani', 'ggtree.ecoli.phages.passages.rectangular.pdf'),
#+END_SRC

** Include
#+BEGIN_SRC snakemake
include:
    'rules/relative_abundace.smk'
#+END_SRC

* Rules
** Merging all reads
:PROPERTIES:
:COOKIE_DATA: todo recursive
:header-args: :tangle workflow/rules/assembly_merged_reads.smk :mkdirp yes :exports none :eval never-export :comments link
:END:
*** Merge reads
#+BEGIN_SRC snakemake
rule prefix_fastq:
    input:
        samples=expand(join_path(config['data']['reads'], '{sample}.merged.fastq'), sample=SAMPLES),
    params:
        samples_prefixed = join_path(config['data']['reads'], 'P1-10.merged.prefixed.before_qc.fastq'),
    output:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.before_qc.fastq.gz'),
    threads:
        get_cores_perc(1)
    shell:
        """
        echo {input.samples} \
            | tr ' ' '\\n' \
            | while read sample; do
                prefix=$( basename $sample | cut -d'.' -f1)
                sed -r '/^@.+runid/ s/^@/@'$prefix'#1#/' $sample >> {params.samples_prefixed}
            done
        pigz -p {threads} {params.samples_prefixed}
        """
#+END_SRC

*** nanoplot
Get some quality check data (mostly read length distribution):
#+BEGIN_SRC snakemake
rule nanoplot:
    input:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.{state}_qc.fastq.gz'),
    output:
        directory("results/nanoplot/{state}_filter")
    threads:
        get_cores_perc(0.5)
    conda:
        "../envs/nanoplot_env.yaml"
    shell:
        "NanoPlot -t {threads} --plots dot -o {output} --fastq {input}"
#+END_SRC

*** FILTER READS
#+BEGIN_SRC snakemake
rule filter_reads:
    input:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.before_qc.fastq.gz'),
    output:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.after_qc.fastq.gz'),
    params:
        **config['params']['filtlong']
    conda:
        "../envs/filtlong_env.yaml"
    threads:
        get_cores_perc(0.2)
    shell:
        "filtlong --min_length {params.min_length} --keep_percent {params.keep_percent} {input} | pigz -p {threads} > {output}"
#+END_SRC

*** MINIA3
Genome assembly with [[https:https://github.com/GATB/minia][minia3]]:
#+BEGIN_SRC snakemake
rule minia:
    input:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.after_qc.fastq.gz'),
    output:
        minia_assembly=minia_prefix+".contigs.fa"
    threads:
        get_cores_perc(1)
    params:
        **config['params']['minia'],
        prefix_fasta=minia_prefix
    conda:
        '../envs/minia_env.yaml'
    shell:
        "minia -nb-cores {threads} -kmer-size {params.kmer} -abundance-min {params.abundance} -out {params.prefix_fasta} -in {input}"
#+END_SRC

*** FASTA_TO_GFA
#+BEGIN_SRC snakemake
rule minia_fasta_to_gfa:
    input:
        minia_assembly=minia_prefix+".contigs.fa",
        script=join_path(snakefile_path, 'scripts', 'convertToGFA.py'),
    output:
        minia_assembly_gfa=minia_prefix+'.contigs.gfa'
    params:
        **config['params']['minia'],
    conda:
        '../envs/minia_env.yaml'
    shell:
        "python {input.script} {input.minia_assembly} {output.minia_assembly_gfa} {params.kmer}"
#+END_SRC

*** Graphaligner MINIA
#+BEGIN_SRC snakemake
rule polishing_graphaligner_minia:
    input:
        filtered = join_path(config['data']['reads'], 'filtered', '{sample}.filtered.fastq.gz'),
        minia_assembly_gfa = join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.gfa'),
    output:
        minia_gaf = join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.gaf'),
        polished_reads_fasta = join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.fa'),
        polished_reads = join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.fa.gz'),
    threads:
        get_cores_perc(0.3)
    params:
        dbtype = "vg",
        seed_minimizer = 15
    conda:
        '../envs/graphaligner_env.yaml'
    shell:
        "GraphAligner -g {input.minia_assembly_gfa} -f {input.filtered} -x {params.dbtype} "
        "--threads {threads} --seeds-minimizer-length {params.seed_minimizer} "
        "--seeds-minimizer-windowsize {params.seed_minimizer} -a {output.minia_gaf} "
        "--corrected-out {output.polished_reads_fasta} && "
        "cat {output.polished_reads_fasta} | bgzip -@ {threads} > {output.polished_reads}"
#+END_SRC

*** Filter by length
#+BEGIN_SRC snakemake
rule filter_by_length_and_index:
    input:
        minia_assembly_gfa_polished = join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.polished.fa'),
        script = join_path(snakefile_path, 'scripts', 'filter_by_length.py')
    output:
        minia_assembly_polished_filtered = join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.polished' + filter_contigs_prefix + ".fa.gz"),
        fai = join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.polished' + filter_contigs_prefix + ".fa.gz.fai"),
        gzi = join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.polished' + filter_contigs_prefix + ".fa.gz.gzi"),
    params:
        **config['params']['minia']
    conda:
        '../envs/bio_env.yaml'
    threads:
        1
    shell:
        "python3 {input.script} {input.minia_assembly_gfa_polished} {params.min_contig_lenght}  {params.max_contig_lenght} | bgzip > {output.minia_assembly_polished_filtered} && "
        "samtools faidx {output.minia_assembly_polished_filtered}"
#+END_SRC

*** Create index
#+BEGIN_SRC snakemake
rule create_index_fasta:
    input:
        minia_assembly_polished_filtered = filter_contigs_prefix + '.contigs.polished.fa',
    output:
        minia_assembly_polished_filtered_crompressed = filter_contigs_prefix + '.contigs.polished.fa.gz',
        fai = filter_contigs_prefix + '.contigs.polished.fa.gz.fai',
        gzi = filter_contigs_prefix + '.contigs.polished.fa.gz.gzi',
    threads:
        get_cores_perc(0.5)
    conda:
        '../envs/pggb_env.yaml'
    shell:
        "cat {input.minia_assembly_polished_filtered} | bgzip -@ {threads} > {output.minia_assembly_polished_filtered_crompressed} && "
        "samtools faidx {output.minia_assembly_polished_filtered_crompressed}"
#+END_SRC

*** Get sample and add parental phages genomes
#+BEGIN_SRC snakemake
rule add_parental_genomes_and_get_sample:
    input:
        minia_assembly_polished_filtered_crompressed = filter_contigs_prefix + '.contigs.polished.fa.gz',
        parental_genomes = config['data']['genomes']['ecoli_and_phages']
    params:
        prefix = filter_contigs_prefix + '.contigs.polished.sample1K.fa',
    output:
        minia_assembly_polished_filtered_crompressed_sampled = filter_contigs_prefix + '.contigs.polished.sample1K.fa.gz',
        fai = filter_contigs_prefix + '.contigs.polished.sample1K.fa.gz.fai',
        gzi = filter_contigs_prefix + '.contigs.polished.sample1K.fa.gz.gzi',
    threads:
        get_cores_perc(0.8)
    conda:
        '../envs/pggb_env.yaml'
    shell:
        "cat {input.parental_genomes} > {params.prefix} && "
        "samtools faidx {input.minia_assembly_polished_filtered_crompressed} "
        "$( seq 1 10 | while read i; do zgrep  -P '^>P'$i'#' {input.minia_assembly_polished_filtered_crompressed} | shuf -n 100 ; done | sed 's/>//' ) "
        ">> {params.prefix} && "
        " bgzip -@ {threads}  {params.prefix} && "
        " samtools faidx {output.minia_assembly_polished_filtered_crompressed_sampled}"
#+END_SRC

*** PGGB minia_polished
#+BEGIN_SRC snakemake
rule pggb_minia:
    input:
        minia_assembly_polished_filtered_crompressed_sampled = filter_contigs_prefix + '.contigs.polished.sample1K.fa.gz',
        fai = filter_contigs_prefix + '.contigs.polished.sample1K.fa.gz.fai',
        gzi = filter_contigs_prefix + '.contigs.polished.sample1K.fa.gz.gzi',
    output:
        directory( "results/pggb/minia.assembly" + pggb_prefix + ".ecoli.and.phages" ),
    params:
        **config['params']['pggb']
    conda:
        '../envs/pggb_env.yaml'
    threads:
        get_cores_perc(1)
    shell:
        "n_mappings=$( zgrep -c '>' {input.minia_assembly_polished_filtered_crompressed_sampled} ) && "
        " pggb -m -p {params.map_pct_id} -n $n_mappings -s {params.segment_length} -l {params.block_length} -t {threads} -o {output} -i {input.minia_assembly_polished_filtered_crompressed_sampled}"
#+END_SRC

*** Get distance matrix
#+BEGIN_SRC snakemake
rule odgi_get_distance_matrix:
    input:
        odgi_graph = glob.glob(join_path("results/pggb/minia.assembly" + pggb_prefix + ".ecoli.and.phages",  '*.smooth.final.og'))[0]
    output:

#+END_SRC

** Assembly each passage
:PROPERTIES:
:COOKIE_DATA: todo recursive
:header-args: :tangle workflow/rules/assembly_each_passage_reads.smk :mkdirp yes :exports none :eval never-export :comments link
:END:
*** Prefix reads
#+BEGIN_SRC snakemake
rule prefix_fastq:
    input:
        sample = join_path(config['data']['reads'], '{sample}.merged.fastq'),
    output:
        sample_prefixed = join_path(config['data']['reads'], 'prefixed', '{sample}.prefixed.fastq.gz')
    threads:
        get_cores_perc(1)
    conda:
        '../envs/pggb_env.yaml'
    shell:
        "prefix=$( basename {input.sample} | cut -d'.' -f1) && "
        "sed -r '/^@.+runid/ s/^@/@'$prefix'#1#/' {input.sample} | bgzip > {output.sample_prefixed}"
#+END_SRC

*** nanoplot
Get some quality check data (mostly read length distribution):
#+BEGIN_SRC snakemake
rule quality_check_plot_before_filtering:
    input:
        sample = join_path(config['data']['reads'], '{state}', '{sample}.{state}.fastq.gz')
    output:
        plot_dir = directory("results/single/nanoplot/{state}/{sample}")
    threads:
        get_cores_perc(1)
    conda:
        "../envs/nanoplot_env.yaml"
    shell:
        "NanoPlot -t 2 --plots dot -o {output.plot_dir} --fastq {input.sample}"
#+END_SRC

*** FILTER READS
#+BEGIN_SRC snakemake
rule filter_reads:
    input:
        prefixed = join_path(config['data']['reads'], 'prefixed', '{sample}.prefixed.fastq.gz')
    output:
        filtered = join_path(config['data']['reads'], 'filtered', '{sample}.filtered.fastq.gz')
    params:
        ,**config['params']['filtlong']
    conda:
        "../envs/filtlong_env.yaml"
    threads:
        10
    shell:
        "filtlong --min_length {params.min_length} --keep_percent {params.keep_percent} {input.prefixed} | pigz > {output.filtered}"
#+END_SRC

*** Minia assembly
Genome assembly with [[https:https://github.com/GATB/minia][minia3]]:
#+BEGIN_SRC snakemake
rule minia:
    input:
        prefixed = join_path(config['data']['reads'], 'prefixed', '{sample}.prefixed.fastq.gz'),
        script_abundance = join_path(snakefile_path, 'scripts', 'get_abundance.sh'),
    output:
        minia_assembly =  join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.fa'),
    threads:
        4
    params:
        **config['params']['minia'],
    conda:
        '../envs/minia_env.yaml'
    shell:
        "RELATIVE_ABUNDACE=$( {input.script_abundance} {params.P1_abundance} {params.P1_bp} {input.prefixed} ) && "
        "minia -nb-cores {params.cores} -kmer-size {params.kmer} -abundance-min $RELATIVE_ABUNDACE "
        "-out $(echo {output.minia_assembly} | sed 's/.contigs.fa//') -in {input.prefixed} && "
        "find $( dirname {output.minia_assembly} ) -type f ! -name '*'$(basename {output.minia_assembly}) -exec rm {{}} \;"
#+END_SRC
*** fasta to gfa
#+BEGIN_SRC snakemake
rule minia_fasta_to_gfa:
    input:
        minia_assembly =  join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.fa'),
        script = join_path(snakefile_path, 'scripts', 'convertToGFA.py'),
    output:
        minia_assembly_gfa = join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.gfa')
    params:
        **config['params']['minia'],
    conda:
        '../envs/minia_env.yaml'
    threads:
        10
    shell:
        "python {input.script} {input.minia_assembly} {output.minia_assembly_gfa} {params.kmer}"
#+END_SRC

*** Graphaligner MINIA
#+BEGIN_SRC snakemake
rule polishing_graphaligner_minia:
    input:
        samples_prefixed_gzipped = join_path(config['data']['reads'], 'prefixed', '{sample}.prefixed.fastq.gz'),
        minia_assembly_gfa = join_path('results', 'single', 'minia', '{sample}', '{sample}.' + minia_prefix + ".contigs.gfa")
    output:
        minia_gaf = join_path('results', 'single', 'minia', '{sample}', '{sample}.' + minia_prefix + ".contigs.polished.gaf"),
        minia_assembly_gfa_polished = join_path('results', 'single', 'minia', '{sample}', '{sample}.' + minia_prefix + ".contigs.polished.fa"),
    threads:
        4
    params:
        dbtype = "vg",
        seed_minimizer = 15
    conda:
        '../envs/graphaligner_env.yaml'
    shell:
        "GraphAligner -g {input.minia_assembly_gfa} -f {input.samples_prefixed_gzipped} -x {params.dbtype} --threads 10 --seeds-minimizer-length {params.seed_minimizer} --seeds-minimizer-windowsize {params.seed_minimizer} -a {output.minia_gaf} --corrected-out {output.minia_assembly_gfa_polished}"
#+END_SRC

**** TODO Add graphaligner to pggb_env
*** Filter by length
#+BEGIN_SRC snakemake
rule filter_by_length_and_index:
    input:
        minia_assembly_gfa_polished = join_path('results', 'single', 'minia', '{sample}', '{sample}.' + minia_prefix + ".contigs.polished.fa"),
        script = join_path(snakefile_path, 'scripts', 'filter_by_length.py')
    output:
        minia_assembly_polished_filtered = join_path('results', 'single', 'minia', '{sample}', '{sample}.' + minia_prefix + ".contigs.polished" + filter_contigs_prefix + ".fa.gz"),
        fai = join_path('results', 'single', 'minia', '{sample}', '{sample}.' + minia_prefix + ".contigs.polished" + filter_contigs_prefix + ".fa.gz.fai"),
        giz = join_path('results', 'single', 'minia', '{sample}', '{sample}.' + minia_prefix + ".contigs.polished" + filter_contigs_prefix + ".fa.gz.gzi"),
    params:
        ,**config['params']['minia']
    conda:
        '../envs/bio_env.yaml'
    threads:
        10
    shell:
        "python3 {input.script} {input.minia_assembly_gfa_polished} {params.min_contig_lenght}  {params.max_contig_lenght} | bgzip > {output.minia_assembly_polished_filtered} && "
        "samtools faidx {output.minia_assembly_polished_filtered}"
#+END_SRC
**** TODO ADD samtools to bio_env or add biopython to pggb_env
*** Sample 1000
#+BEGIN_SRC snakemake
rule sample_genomes:
    input:
        polished_reads = join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.fa.gz'),
    output:
        polished_reads = join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.sample.fa.gz' ),
    params:
        sample_size = 100
    threads:
        4
    shell:
        "samtools faidx {input.polished_reads} $(zgrep '>' {input.polished_reads} | sed 's/>//' | cut -d ' ' -f1 | shuf -n {params.sample_size}) | "
        "bgzip > {output.polished_reads}"
#+END_SRC
*** Merge samples
#+BEGIN_SRC snakemake
rule merge_samples_and_parental_genomes:
    input:
        polished_reads = expand(join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.sample.fa.gz' ), sample=SAMPLES),
        ecoli_and_phages = config['data']['genomes']['ecoli_and_phages'],
    output:
        pggb_input = join_path('results', results_dir, 'pggb', 'minia.merged.1K.sample.fa.gz'),
        fai = join_path('results', results_dir, 'pggb', 'minia.merged.1K.sample.fa.gz.fai'),
        gzi = join_path('results', results_dir, 'pggb', 'minia.merged.1K.sample.fa.gz.gzi'),
    conda:
        '../envs/pggb_env.yaml'
    threads:
        get_cores_perc(1)
    shell:
        "cat {input.ecoli_and_phages} <(zcat {input.polished_reads}) | bgzip -@ {threads} > {output.pggb_input} && "
        "samtools faidx {output.pggb_input}"
#+END_SRC
*** Pangenome PGGB
#+BEGIN_SRC snakemake
rule pggb_pangenome:
    input:
        pggb_input = join_path('results', results_dir, 'pggb', 'minia.merged.1K.sample.fa.gz'),
        fai = join_path('results', results_dir, 'pggb', 'minia.merged.1K.sample.fa.gz.fai'),
        gzi = join_path('results', results_dir, 'pggb', 'minia.merged.1K.sample.fa.gz.gzi'),
    output:
        pggb_out = directory(join_path('results', results_dir, 'pggb', 'out')),
    params:
        **config['params']['pggb']
    threads:
        get_cores_perc(1)
    conda:
        '../envs/pggb_env.yaml'
    shell:
        "n_mappings=$( zgrep -c '>' {input.pggb_input} ) && "
        "pggb -m -p {params.map_pct_id} -n $n_mappings -s {params.segment_length} -l {params.block_length} -t {threads} -o {output.pggb_out} -i {input.pggb_input}"
#+END_SRC
*** Get distance
#+BEGIN_SRC snakemake
rule get_distance_metrics:
    input:
        pggb_out = join_path('results', results_dir, 'pggb', 'out'),
    output:
        distance_tsv = join_path('results', results_dir, 'pggb', 'distance_matrix.tsv'),
    threads:
        get_cores_perc(1)
    conda:
        '../envs/pggb_env.yaml'
    shell:
        "odgi paths -t {threads} -d -i {input.pggb_out}/*.smooth.final.og > {output.distance_tsv}"
#+END_SRC
*** R phylogeny
#+BEGIN_SRC snakemake
# rule phylogeny:
#     input:
#         distance_tsv = join_path('results', 'single', 'pggb', 'distance_matrix.tsv'),
#         script = join_path(snakefile_path, 'scripts', 'phylogeny.R'),
#     output:
#         phylogeny_svg = join_path('results', 'phylogeny', 'tree.svg'),
#         phylogeny_pdf = join_path('results', 'phylogeny', 'tree.pdf'),
#         phylogeny_newick = join_path('results', 'phylogeny', 'tree.newick'),
#         pca_pdf = join_path('results', 'phylogeny', 'pca.pdf'),

#+END_SRC
*** Genomic anotation

** Best Abundance
:PROPERTIES:
:COOKIE_DATA: todo recursive
:header-args: :tangle workflow/rules/best_abundance.smk :mkdirp yes :exports none :eval never-export :comments link
:END:
*** Minia assembly
Genome assembly with [[https:https://github.com/GATB/minia][minia3]]:
#+BEGIN_SRC snakemake
rule minia:
    input:
        filtered = join_path(config['data']['reads'], 'prefixed', 'P1.prefixed.fastq.gz')
    output:
        minia_assembly =  join_path('results', 'test_abundance', 'minia', 'A{abundance}.K{kmer}', 'minia.assembly.contigs.fa')
    threads:
        6
    params:
        kmer = '{kmer}',
        abundance = '{abundance}',
    conda:
        '../envs/minia_env.yaml'
    shell:
        "minia -nb-cores 5 -kmer-size {params.kmer} -abundance-min {params.abundance} -out $( echo {output.minia_assembly} | sed 's/.contigs.fa//' ) -in {input.filtered} && "
        " find $( dirname {output.minia_assembly} ) -type f ! -name '*'$(basename {output.minia_assembly}) -exec rm {{}} \;"
#+END_SRC
*** fasta to gfa
#+BEGIN_SRC snakemake
rule minia_fasta_to_gfa:
    input:
        minia_assembly =  join_path('results', 'test_abundance', 'minia', 'A{abundance}.K{kmer}', 'minia.assembly.contigs.fa'),
        script = join_path(snakefile_path, 'scripts', 'convertToGFA.py'),
    output:
        minia_assembly_gfa =  join_path('results', 'test_abundance', 'minia', 'A{abundance}.K{kmer}', 'minia.assembly.contigs.gfa'),
    params:
        kmer = '{kmer}',
    conda:
        '../envs/minia_env.yaml'
    threads:
        10
    shell:
        "python {input.script} {input.minia_assembly} {output.minia_assembly_gfa} {params.kmer}"
#+END_SRC

** relative_abundace
:PROPERTIES:
:COOKIE_DATA: todo recursive
:header-args: :tangle workflow/rules/relative_abundace.smk :mkdirp yes :exports none :eval never-export :comments link
:END:
*** config
#+BEGIN_SRC snakemake
# results_dir = os.path.basename(workflow.snakefile).replace('.smk', '')
#+END_SRC
*** Prefix reads
#+BEGIN_SRC snakemake
rule prefix_fastq:
    input:
        sample = join_path(config['data']['reads'], '{sample}.merged.fastq'),
    output:
        sample_prefixed = join_path(config['data']['reads'], 'prefixed', '{sample}.prefixed.fastq.gz')
    threads:
        get_cores_perc(1)
    conda:
        '../envs/pggb_env.yaml'
    shell:
        "prefix=$( basename {input.sample} | cut -d'.' -f1) && "
        "sed -r '/^@.+runid/ s/^@/@'$prefix'#1#/' {input.sample} | bgzip > {output.sample_prefixed}"
#+END_SRC
*** FASTQ lenght filtering
#+BEGIN_SRC snakemake
rule filter_reads:
    input:
        prefixed = join_path(config['data']['reads'], 'prefixed', '{sample}.prefixed.fastq.gz')
    output:
        filtered = join_path(config['data']['reads'], 'filtered', '{sample}.filtered.fastq.gz')
    params:
        **config['params']['seqkit']
    conda:
        "../envs/seqkit_env.yaml"
    threads:
        4
    shell:
        "seqkit seq {input.prefixed} -j {threads} -m {params.min} -M {params.max} | bgzip > {output.filtered}"
#+END_SRC
**** TODO Remember to add bgzip to seqkit env maybe
*** Minia assembly
Genome assembly with [[https:https://github.com/GATB/minia][minia3]]:
#+BEGIN_SRC snakemake
rule minia:
    input:
        prefixed = join_path(config['data']['reads'], 'prefixed', '{sample}.prefixed.fastq.gz'),
        script_abundance = join_path(snakefile_path, 'scripts', 'get_abundance.sh'),
    output:
        minia_assembly =  join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.fa'),
    threads:
        4
    params:
        ,**config['params']['minia'],
    conda:
        '../envs/minia_env.yaml'
    shell:
        "RELATIVE_ABUNDACE=$( {input.script_abundance} {params.P1_abundance} {params.P1_bp} {input.prefixed} ) && "
        "minia -nb-cores {params.cores} -kmer-size {params.kmer} -abundance-min $RELATIVE_ABUNDACE "
        "-out $(echo {output.minia_assembly} | sed 's/.contigs.fa//') -in {input.prefixed} && "
        "find $( dirname {output.minia_assembly} ) -type f ! -name '*'$(basename {output.minia_assembly}) -exec rm {{}} \;"
#+END_SRC
*** fasta to gfa
#+BEGIN_SRC snakemake
rule minia_fasta_to_gfa:
    input:
        minia_assembly =  join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.fa'),
        script = join_path(snakefile_path, 'scripts', 'convertToGFA.py'),
    output:
        minia_assembly_gfa = join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.gfa')
    params:
        ,**config['params']['minia'],
    conda:
        '../envs/minia_env.yaml'
    threads:
        10
    shell:
        "python {input.script} {input.minia_assembly} {output.minia_assembly_gfa} {params.kmer}"
#+END_SRC

*** Graphaligner MINIA
#+BEGIN_SRC snakemake
rule polishing_graphaligner_minia:
    input:
        filtered = join_path(config['data']['reads'], 'filtered', '{sample}.filtered.fastq.gz'),
        minia_assembly_gfa = join_path('results', results_dir, 'minia', '{sample}', '{sample}.contigs.gfa'),
    output:
        minia_gaf = join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.gaf'),
        polished_reads_fasta = join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.fa'),
        polished_reads = join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.fa.gz'),
    threads:
        get_cores_perc(0.3)
    params:
        dbtype = "vg",
        seed_minimizer = 15
    conda:
        '../envs/graphaligner_env.yaml'
    shell:
        "GraphAligner -g {input.minia_assembly_gfa} -f {input.filtered} -x {params.dbtype} "
        "--threads {threads} --seeds-minimizer-length {params.seed_minimizer} "
        "--seeds-minimizer-windowsize {params.seed_minimizer} -a {output.minia_gaf} "
        "--corrected-out {output.polished_reads_fasta} && "
        "cat {output.polished_reads_fasta} | bgzip -@ {threads} > {output.polished_reads}"
#+END_SRC

**** TODO Add graphaligner to pggb_env
*** Sample genomes
#+BEGIN_SRC snakemake
rule sample_genomes:
    input:
        polished_reads = join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.fa.gz'),
    output:
        polished_reads = join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.sample.' + str(config['sample_size']) + '.fa.gz' ),
    params:
        sample_size = config['sample_size']
    threads:
        4
    shell:
        "samtools faidx {input.polished_reads} $(zgrep '>' {input.polished_reads} | sed 's/>//' | cut -d ' ' -f1 | shuf -n {params.sample_size}) | "
        "bgzip > {output.polished_reads}"
#+END_SRC
*** Merge samples
#+BEGIN_SRC snakemake
rule merge_samples_and_parental_genomes:
    input:
        polished_reads = expand(join_path('results', results_dir, 'minia', '{sample}', '{sample}.reads.polished.sample.' + str(config['sample_size']) + '.fa.gz' ), sample=SAMPLES),
        ecoli_and_phages = config['data']['genomes']['ecoli_and_phages'],
    output:
        pggb_input = join_path('results', results_dir, 'pggb', 'minia.merged.' + str(config['sample_size']) + '.sample.fa.gz'),
        fai = join_path('results', results_dir, 'pggb', 'minia.merged.' + str(config['sample_size']) + '.sample.fa.gz.fai'),
        gzi = join_path('results', results_dir, 'pggb', 'minia.merged.' + str(config['sample_size']) + '.sample.fa.gz.gzi'),
    conda:
        '../envs/pggb_env.yaml'
    threads:
        get_cores_perc(1)
    shell:
        "cat {input.ecoli_and_phages} <(zcat {input.polished_reads}) | bgzip -@ {threads} > {output.pggb_input} && "
        "samtools faidx {output.pggb_input}"
#+END_SRC
*** Pangenome PGGB
#+BEGIN_SRC snakemake
rule pggb_pangenome:
    input:
        pggb_input = join_path('results', results_dir, 'pggb', 'minia.merged.' + str(config['sample_size']) + '.sample.fa.gz'),
        fai = join_path('results', results_dir, 'pggb', 'minia.merged.' + str(config['sample_size']) + '.sample.fa.gz.fai'),
        gzi = join_path('results', results_dir, 'pggb', 'minia.merged.' + str(config['sample_size']) + '.sample.fa.gz.gzi'),
    output:
        pggb_out = directory(join_path('results', results_dir, 'pggb', 'out')),
    params:
        ,**config['params']['pggb']
    threads:
        get_cores_perc(1)
    conda:
        '../envs/pggb_env.yaml'
    shell:
        "n_mappings=$( zgrep -c '>' {input.pggb_input} ) && "
        "pggb -m -p {params.map_pct_id} -n $n_mappings -s {params.segment_length} -l {params.block_length} -k {params.min_match_len} -B {params.transclose_batch} -t {threads} -o {output.pggb_out} -i {input.pggb_input}"
#+END_SRC
*** Get distance
#+BEGIN_SRC snakemake
rule get_distance_metrics:
    input:
        pggb_out = join_path('results', results_dir, 'pggb', 'out'),
    output:
        distance_tsv = join_path('results', results_dir, 'pggb', 'distance_matrix.sample.' + str(config['sample_size']) + '.tsv'),
    threads:
        get_cores_perc(1)
    conda:
        '../envs/pggb_env.yaml'
    shell:
        "odgi paths -t {threads} -d -i {input.pggb_out}/*.smooth.final.og > {output.distance_tsv}"
#+END_SRC
*** Plot phylogeny
#+BEGIN_SRC snakemake
rule plot_phylogeny:
    input:
        distance_tsv = join_path('results', results_dir, 'pggb', 'distance_matrix.sample.' + str(config['sample_size']) + '.tsv'),
        script_phylogeny = join_path(snakefile_path, 'scripts', 'phylogeny.R'),
    output:
        rectangular = join_path('results', results_dir, 'plots', 'ggtree.ecoli.phages.passages.rectangular.pdf'),
        daylight = join_path('results', results_dir, 'plots', 'ggtree.ecoli.phages.passages.daylight.pdf'),
    conda:
        '../envs/R_env.yaml'
    threads:
        1
    shell:
        "Rscript {input.script_phylogeny} {input.distance_tsv} {output.rectangular}"
#+END_SRC
*** Split_multifasta
#+BEGIN_SRC snakemake
rule split_multifasta:
    input:
        pggb_input = join_path('results', results_dir, 'pggb', 'minia.merged.' + str(config['sample_size']) + '.sample.fa.gz'),
        fai = join_path('results', results_dir, 'pggb', 'minia.merged.' + str(config['sample_size']) + '.sample.fa.gz.fai'),
        gzi = join_path('results', results_dir, 'pggb', 'minia.merged.' + str(config['sample_size']) + '.sample.fa.gz.gzi'),
    output:
        split_fastas_paths = join_path('results', results_dir, 'split_fastas_sample' + str(config['sample_size']), 'all_fastas_paths.txt')
    conda:
        '../envs/pggb_env'
    threads:
        1
    shell:
        "fasta_dir=$(dirname {output.split_fastas_paths}) && "
        "zgrep '>' {input.pggb_input} | sed 's/>//' | "
        "while read f; do samtools faidx {input.pggb_input} $f > ${{fasta_dir}}/${{f}}.fa; done && "
        "find $fasta_dir -name '*.fa' -exec readlink -f {{}} \; > {output.split_fastas_paths}"
#+END_SRC

*** FASTANI_DISTANCE
#+BEGIN_SRC snakemake
rule fastaANI_distance_matrix:
    input:
        split_fastas_paths = join_path('results', results_dir, 'split_fastas_sample' + str(config['sample_size']), 'all_fastas_paths.txt')
    output:
        fastani_distance_matrix = join_path('results', results_dir, 'plots','fastani', 'fastani_distance_matrix.tsv'),
    conda:
        '../envs/fastani_env.yaml'
    threads:
        get_cores_perc(1)
    shell:
        "fastANI  -t {threads} --fragLen 200 --ql {input.split_fastas_paths} --rl {input.split_fastas_paths} -o /dev/stdout  | "
        "sed -r 's#'$(readlink -f {input.split_fastas_paths} | xargs dirname )'##g;s#.fa##g' | awk -v OFS='\\t' '{{print $1,$2,$3}}' >{output.fastani_distance_matrix}"



#+END_SRC
*** FASTANI_PLOT
#+BEGIN_SRC snakemake
rule fastANI_plot_tree:
    input:
        fastani_distance_matrix = join_path('results', results_dir, 'plots','fastani', 'fastani_distance_matrix.tsv'),
        script_phylogeny_fastani = join_path(snakefile_path, 'scripts', 'phylogeny_fastani.R'),
    output:
        rectangular = join_path('results', results_dir, 'plots','fastani', 'ggtree.ecoli.phages.passages.rectangular.pdf'),
        daylight = join_path('results', results_dir, 'plots','fastani', 'ggtree.ecoli.phages.passages.daylight.pdf'),
    conda:
        '../envs/R_envs.yaml'
    threads:
        1
    shell:
        'Rscript {input.script_phylogeny_fastani} {input.fastani_distance_matrix} {output.rectangular}'

#+END_SRC

* CONFIGS
:PROPERTIES:
:COOKIE_DATA: todo recursive
:header-args: :tangle config/config.yaml :mkdirp yes :exports none :eval never-export :comments link
:END:
#+BEGIN_SRC yaml
# data: 'data'

# # Input
# reads: 'data/fastq'
# parental_phages: 'data/genomes/phage/parental.phage.merged.fasta'

sample_size: 3

data:
  reads: 'data/fastq'
  genomes:
    ecoli: 'data/genomes/bacteria/E_coli_bl21_noplasmid.fasta'
    merged: 'data/genomes/bacteria/parental_phages_and_Ecoli_bl21.fasta'
    bacteira: 'data/genomes/bacteria'
    phages: 'data/genomes/phage'
    ecoli_and_phages: 'data/genomes/ecoli_bl21_DE_and_phages_merged.fasta'


results:
  nanoplot:
    before: 'results/nanoplot/before_filter'
    after: 'results/nanoplot/after_filter'
  assemblies:
    minia: 'results/assemblies/minia'
    miniasm: 'results/assemblies/miniasm'

# minia
params:
  minia:
    kmer: 33
    abundance: 4
    min_contig_lenght: 40_000
    max_contig_lenght: 50_000
    P1_abundance: 4
    P1_bp: 186778684
    cores: 10
  filtlong:
    keep_percent: 90
    min_length: 10_000
  pggb:
    map_pct_id: 95
    segment_length: 500
    block_length: 1_000
    min_match_len: 256
    transclose_batch: 10_000
  seqkit:
    min: 40_000
    max: 50_000

# Sample genomes from assembly
#+END_SRC
* Notes
- Some tools cannot be built through conda only:
  - R: that are some libs that must be isntall manually on the R console:
    - remotes::install_github("YuLab-SMU/ggtree")
    - install.packages("stringi",dep=TRUE)
    - devtools::install_github("tidyverse/tidyr")
  - PGGB: Works better if installed through GUIX
-
** TODO Make a docker container with conda and GUIX
