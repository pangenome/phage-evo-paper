#+TITLE: Main file of the phage repo
#+AUTHOR: Hugo Ávila (@bioinformagica)
#+LANGUAGE: en-us
#+STARTUP: overview
#+PROPERTY: header-args :dir ~/projects/phage-evo-paper :mkdirp yes :exports none :eval never-export

* ENV setup
** Snakemake
#+BEGIN_SRC shell
# get conda installer
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh

# Run installer and interactively accept and init the conda executable
# Atention !!!: this will change your current shell .rc (.zshrc, .bashrc ...)
bash Miniconda3-latest-Linux-x86_64.sh

# Source the conda changes
source ~/.bashrc

# Set auto activation of conda base environment to false
conda config --set auto_activate_base false

# Add channels
conda config --add channels conda-forge
conda config --add channels bioconda

# Install mamba
conda install -n base -c conda-forge mamba -y

# Install Snakemake
mamba create -c conda-forge -c bioconda -n snakemake snakemake -y

#+END_SRC

#+RESULTS:

* Snakemake workflow template
#+NAME: cb:get-snakemake-template
#+CAPTION: Clone the Snakemake Template
#+BEGIN_SRC shell
git clone https://github.com/snakemake-workflows/snakemake-workflow-template .
rm -rf .git
git init && git commit --allow-empty -m "Initial Commit."
#+END_SRC

* README.md
#+NAME: cb:README.md
#+CAPTION: README.md
#+BEGIN_SRC markdown :tangle README.md
# Snakemake workflow: `phage-evo-paper`

[![Snakemake](https://img.shields.io/badge/snakemake-≥6.3.0-brightgreen.svg)](https://snakemake.github.io)

A Snakemake workflow for `Phage directed evolution analysis`.
#+END_SRC
** DONE Create README.md
** TODO Create linter action
* Snakefile
:PROPERTIES:
:COOKIE_DATA: todo recursive
:header-args: :tangle workflow/Snakefile :mkdirp yes :exports none :eval never-export :comments link
:END:
** IMPORTS
#+BEGIN_SRC snakemake
import os
import sys
from operator import itemgetter as itget
#+END_SRC

** FILE CONFIGS
#+BEGIN_SRC snakemake
configfile: 'config/config.yaml'
#+END_SRC

** FUNCTIONS
#+BEGIN_SRC snakemake
get_cores_perc = lambda perc: max(1, workflow.cores * perc)
join_path = lambda *args: os.path.join(*args)
get_Kbs = lambda x: int(x/1_000)
#+END_SRC

** GLOBAL VARIABLES
#+BEGIN_SRC snakemake
output_dirs = config['results']
snakefile_path = os.path.dirname(workflow.snakefile)
# SAMPLES=list(map(lambda x: os.path.basename(x.path).replace('.fastq',''), filter(lambda x: x.path.endswith('fastq'), os.scandir(config['reads']))))

# Prefixes
minia_prefix="results/assemblies/minia/minia.k{}.a{}".format(*itget("kmer","abundance")(config['params']['minia']))
pggb_prefix=".p{}.s{}.l{}".format(*itget("map_pct_id", "segment_length", "block_length")(config['params']['pggb']))

# Suffixes
filter_contigs_prefix = minia_prefix + '.min{}Kb.max{}Kb'.format(*iter(map(get_Kbs, itget('min_contig_lenght', 'max_contig_lenght')(config['params']['minia']))))

SAMPLES, = glob_wildcards(join_path(config['data']['reads'], '{sample}.merged.fastq'))
#+END_SRC
** MAIN RULE ALL
#+BEGIN_SRC snakemake
rule all:
    input:
        nanoplot = expand("results/nanoplot/{state}_filter", state=('before', 'after')),
        pggb_dir='results/pggb/minia' + pggb_prefix,
#+END_SRC

** Include
#+BEGIN_SRC snakemake
include:
    'rules/assembly_merged_reads.smk'
    # 'rules/assembly_each_passage_reads.smk'

#+END_SRC

* Rules
** Merging all reads
:PROPERTIES:
:COOKIE_DATA: todo recursive
:header-args: :tangle workflow/rules/assembly_merged_reads.smk :mkdirp yes :exports none :eval never-export :comments link
:END:
*** Merge reads
#+BEGIN_SRC snakemake
rule prefix_fastq:
    input:
        samples=expand(join_path(config['data']['reads'], '{sample}.merged.fastq'), sample=SAMPLES),
    params:
        samples_prefixed=join_path(config['data']['reads'], 'P1-10.merged.prefixed.fastq')
    output:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.before_qc.fastq.gz'),
    threads:
        get_cores_perc(1)
    shell:
        """
        echo {input.samples} \
            | tr ' ' '\\n' \
            | while read sample; do
                prefix=$( basename $sample | cut -d'.' -f1)
                sed -r '/^@.+runid/ s/^@/@'$prefix'#1#/' $sample >> {params.samples_prefixed}
            done
        cat {params.samples_prefixed} | pigz -p {threads} > {output.samples_prefixed_gzipped}
        """
#+END_SRC

*** NANOPLOT
Get some quality check data (mostly read length distribution):
#+BEGIN_SRC snakemake
rule nanoplot:
    input:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.{state}_qc.fastq.gz'),
    output:
        directory("results/nanoplot/{state}_filter")
    threads:
        get_cores_perc(0.5)
    conda:
        "envs/nanoplot_env.yaml"
    shell:
        "NanoPlot -t {threads} --plots dot -o {output} --fastq {input}"
#+END_SRC

*** FILTER READS
#+BEGIN_SRC snakemake
rule filter_reads:
    input:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.before_qc.fastq.gz'),
    output:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.after_qc.fastq.gz'),
    params:
        **config['params']['filtlong']
    conda:
        "envs/filtlong_env.yaml"
    shell:
        "filtlong --min_length {params.min_length} --keep_percent {params.keep_percent} {input} > {output} "
#+END_SRC

*** MINIA3
Genome assembly with [[https:https://github.com/GATB/minia][minia3]]:
#+BEGIN_SRC snakemake
rule minia:
    input:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.after_qc.fastq.gz'),
    output:
        minia_assembly=minia_prefix+".contigs.fa"
    threads:
        get_cores_perc(0.5)
    params:
        **config['params']['minia'],
        prefix_fasta=minia_prefix
    conda:
        'envs/minia_env.yaml'
    shell:
        "minia -nb-cores {threads} -kmer-size {params.kmer} -abundance-min {params.abundance} -out {params.prefix_fasta} -in {input}"
#+END_SRC

*** FASTA_TO_GFA
#+BEGIN_SRC snakemake
rule minia_fasta_to_gfa:
    input:
        minia_assembly=minia_prefix+".contigs.fa",
        script=join_path(snakefile_path, 'scripts', 'convertToGFA.py'),
    output:
        minia_assembly_gfa=minia_prefix+'.contigs.gfa'
    params:
        **config['params']['minia'],
    conda:
        'envs/minia_env.yaml'
    shell:
        "python {input.script} {input.minia_assembly} {output.minia_assembly_gfa} {params.kmer}"
#+END_SRC

*** Graphaligner MINIA
#+BEGIN_SRC snakemake
rule polishing_graphaligner_minia:
    conda:
        'envs/graphaligner_env.yaml'
    input:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.before_qc.fastq.gz'),
        minia_assembly_gfa=minia_prefix+'.contigs.gfa'
    output:
        minia_gaf=minia_prefix+'.contigs.gaf',
        minia_assembly_gfa_polished=minia_prefix+'.contigs.polished.fa'
    threads:
        get_cores_perc(1)
    params:
        dbtype = "vg",
        seed_minimizer = 15
    shell:
        "GraphAligner -g {input.minia_assembly_gfa} -f {input.samples_prefixed_gzipped} -x {params.dbtype} --threads {threads} --seeds-minimizer-length {params.seed_minimizer} --seeds-minimizer-windowsize {params.seed_minimizer} -a {output.minia_gaf} --corrected-out {output.minia_assembly_gfa_polished}"
#+END_SRC

*** Filter by length
#+BEGIN_SRC snakemake
rule filter_by_length:
    input:
        minia_assembly_gfa_polished=minia_prefix+'.contigs.polished.fa',
        script = join_path(snakefile_path, 'scripts', 'filter_by_length.py')
    output:
        minia_assembly_polished_filtered = filter_contigs_prefix + '.contigs.polished.fa'
    params:
        **config['params']['minia']
    conda:
        'envs/bio_env.yaml'
    shell:
        "python3 {input.script} {params.min_contig_lenght}  {params.max_contig_lenght} > {output.minia_assembly_polished_filtered}"
#+END_SRC

*** Create index
#+BEGIN_SRC snakemake
rule create_index_fasta:
    input:
        minia_assembly_polished_filtered = filter_contigs_prefix + '.contigs.polished.fa',
    output:
        minia_assembly_polished_filtered_crompressed = filter_contigs_prefix + '.contigs.polished.fa.gz',
        fai = filter_contigs_prefix + '.contigs.polished.fa.gz.fai',
        gzi = filter_contigs_prefix + '.contigs.polished.fa.gz.gzi',
    threads:
        get_cores_perc(0.5)
    conda:
        'envs/pggb_env.yaml'
    shell:
        "cat {input.minia_assembly_polished_filtered} | bzip -@ {threads} > {output.minia_assembly_polished_filtered_crompressed} && "
        "samtools faidx {output.minia_assembly_polished_filtered_crompressed}"
#+END_SRC

*** Get sample and add parental phages genomes
#+BEGIN_SRC snakemake
# rule add_parental_genomes_and_get_sample:
#     input:



#+END_SRC

*** PGGB minia_polished
#+BEGIN_SRC snakemake
rule pggb_minia:
    input:
        minia_assembly_polished_filtered_crompressed = filter_contigs_prefix + '.contigs.polished.fa.gz',
        fai = filter_contigs_prefix + '.contigs.polished.fa.gz.fai',
        gzi = filter_contigs_prefix + '.contigs.polished.fa.gz.gzi',
    output:
        directory("results/pggb/minia"+pggb_prefix),
    params:
        ,**config['params']['pggb']
    conda:
        'envs/pggb_env.yaml'
    threads:
        get_cores_perc(1)
    shell:
        "n_mappings=$( zgrep -c '>' {input.minia_assembly_polished_filtered_crompressed} ) && " # get number of genomes
        "pggb -m -p {params.map_pct_id} -n $n_mappings -s {params.segment_length} -l {params.block_length} -t {threads} -o {output} -i {input.minia_assembly_polished_filtered_crompressed}"
#+END_SRC
** Assembly each passage
:PROPERTIES:
:COOKIE_DATA: todo recursive
:header-args: :tangle workflow/rules/assembly_each_passage_reads.smk :mkdirp yes :exports none :eval never-export :comments link
:END:
*** Map reads to minia assembly
#+BEGIN_SRC snakemake
rule prefix_fastq:
    input:
        samples=expand(join_path(config['data']['reads'], '{sample}.merged.fastq'), sample=SAMPLES),
    params:
        samples_prefixed=join_path(config['data']['reads'], 'P1-10.merged.prefixed.fastq')
    output:
        samples_prefixed_gzipped=join_path(config['data']['reads'], 'P1-10.merged.prefixed.fastq.gz')
    threads:
        get_cores_perc(1)
    shell:
        """
        echo {input.samples} \
            | tr ' ' '\\n' \
            | while read sample; do
                prefix=$( basename $sample | cut -d'.' -f1)
                sed -r '/^@.+runid/ s/^@/@'$prefix'#1#/' $sample >> {params.samples_prefixed}
            done
        cat {params.samples_prefixed} | pigz -p {threads} > {output.samples_prefixed_gzipped}
        """
#+END_SRC

*** Filter out bacterial reads
#+BEGIN_SRC snakemake
rule minimap2_map_reads_to_refs:
    input:
        target = config['data']['genomes']['merged'],
        samples_prefixed_gzipped = join_path(config['data']['reads'], 'P1-10.merged.prefixed.fastq.gz'),
    output:
        all_reads_sam = join_path(config['data']['reads'], 'P1-10.merged.prefixed_X_genomes.sam'),
    params:
        bacteria
    threads:
        get_cores_perc(1)
    conda:
        '../envs/minimap2_env.yaml'
    shell:
        "minimap2 -L -ax map-ont -t {threads} {input.target} {input.samples_prefixed_gzipped} | {output.all_reads_sam} "


#+END_SRC
**** TODO add samtools to minimap2 env

* CONFIGS
:PROPERTIES:
:COOKIE_DATA: todo recursive
:header-args: :tangle config/config.yaml :mkdirp yes :exports none :eval never-export :comments link
:END:
#+BEGIN_SRC yaml
# data: 'data'

# # Input
# reads: 'data/fastq'
# parental_phages: 'data/genomes/phage/parental.phage.merged.fasta'

data:
  reads: 'data/fastq'
  genomes:
    ecoli: 'data/genomes/bacteria/E_coli_bl21_noplasmid.fasta'
    merged: 'data/genomes/bacteria/parental_phages_and_Ecoli_bl21.fasta'
    bacteira: 'data/genomes/bacteria'
    phages: 'data/genomes/phage'

# Results
results:
  nanoplot:
    before: 'results/nanoplot/before_filter'
    after: 'results/nanoplot/after_filter'
  assemblies:
    minia: 'results/assemblies/minia'
    miniasm: 'results/assemblies/miniasm'

# minia
params:
  minia:
    kmer: 21
    abundance: 7
    min_contig_lenght: 20_000
    max_contig_lenght: 200_000
  filtlong:
    keep_percent: 95
    min_length: 1_000
  pggb:
    map_pct_id: 90
    segment_length: 1_000
    block_length: 0
#+END_SRC
* ENVS
:PROPERTIES:
:COOKIE_DATA: todo recursive
:header-args: :mkdirp yes :exports none :eval never-export
:END:

#+NAME: get-env-yaml
#+CAPTION: Creates yaml files from conda envs
#+BEGIN_SRC shell :results org replace
declare -a envs=(
    "nanoplot_env"
    "minia_env"
    "kmergenie_env"
)

envs_dir="workflow/envs"
mkdir -p "${envs_dir}"

for env in "${envs[@]}"; do
    fname="${envs_dir}/${env}.yaml"
    [ -f "${fname}" ] && continue
    mamba env export -n "${env}" >"${fname}" 2>/dev/null
done

ls -v1 "${envs_dir}/"*yaml |
    xargs -I'{}' echo "DONE: {}"
#+END_SRC

#+RESULTS: get-env-yaml
#+begin_src org
DONE: workflow/envs/kmergenie_env.yaml
DONE: workflow/envs/minia_env.yaml
DONE: workflow/envs/nanoplot_env.yaml
#+end_src
